1、java是介于解释型和编译型的语言，先统一编译为字节码文件，然后不同平台的jvm虚拟机负责加载字节码并执行。java分三大版本。Java SE：Standard Edition、Java EE：Enterprise Edition、Java ME：Micro Edition

通俗来说，普通编程用se，企业版ee只是在se的基础上多了大量api和库，以方便开发web应用、数据库、消息服务等，他俩使用的JVM虚拟机完全一致。而ME是针对嵌入式设备的“瘦身版”，虚拟机也有所不同。

2、首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；

如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；

如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；

如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。

3、JRE是java运行环境，能够加载字节码并运行，而JDK除了包含JRE，还包含一系列编译器、调试器等，负责将java源码编译成字节码。

4、java基本程序结构，每一个java源文件包含一个public class单元，含有一个public static void修饰的main函数，参数为string的数组

5、变量分为基本变量和引用变量，整型，浮点型，布尔型，字符型；常量使用final初始化，无法更改。

6、自增减操作   <<、>>二进制移位运算 &、|、~、^位运算

强制类型转换使用（short）i，类型会自动进行提升。

7、浮点数无法精确存储，1 - 9.0 / 10和0.1直接比较不相等，应使用math.abs判断之差是否小于一个阈值。

8、布尔关系运算包含&&、||、！，以及大小和等于判断

9、println代表输出一行（带换行），printf不带换行，且可以进行格式化输出。

10、==用于判断引用变量指向是否相同，如果判断内容是否相同，使用equal。

11、switch语句中的case具有“穿透性”，因此不要忘记break

12、for(int n : ns)增强循环可迭代数据类型的所有元素

13、多维数组不同维度长度可不同，直接使用deeptostring打印。

14、面向对象中的this始终指向当前实例，如果没有命名冲突，可以省略this。

15、可变参数String... names，可以接受0个参数，会自动转换为数组形式。

16、先执行类中属性的初始化，再执行构造方法。

17、方法名称相同，参数不同，返回值可以不同，称之为方法**重载（单类）**。 

18、public修饰的属性和方法可被自身和外部调用，private只可以被自身调用（子类无法访问），protected修饰，则可以将访问范围扩展到继承数内部，符合正常逻辑。

19、super表示引用父类属性和方法，当父类声明了构造方法时（不带参数除外）或者使用了覆写，则需要用到super，invokespecial。

20、在继承中，向上转型一定会成功，因为父类的属性和方法子类一定有，向下转型不一定成功，需要看类型是否相同。

21、继承是is关系，组合是has(implements/extend)关系。

22、子类与父类方法名、返回值、参数相同，称为方法**覆写(父子类)**，如果不希望覆写，父类可在对应方法上前加final。（字段被修饰final，则只能静态/构造初始化，无法修改；用final修饰的类本身无法被继承），

23、一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？答案是Student的方法，Java的实例方法调用是基于运行时的实际类型的动态调用，称之为多态。（多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期的实际类型）类似于python中的read方法，只要对象包含read方法，就可以运行read，其取决于运行read时的 实际类型。（鸭子类型）

24、abstract用于修饰抽象方法，其必须位于抽象类(abstract class)中，抽象类用于定制规范，子类必须实现其抽象方法。由此引申出面向抽象编程的概念。

25、如果抽象类没有属性，只有抽象方法，则可以定义为接口(interface)，实现该接口需要使用implements，无法多继承，但可以多实现。接口之间可以extends，相当于扩展了规范。接口还可以拥有静态字段，只能static final修饰。

26、抽象类比类抽象，而接口比抽象类更抽象，因此，实例化对象时，总是用接口去引用它，面向接口编程工厂模式。

27、default用于在接口中定义默认方法，这样该方法就不需要手动编写实现。

28、普通实例字段只在自己内存空间下有用，静态字段共享一个独立空间，任意通过一个实例修改静态字段效果都一样。推荐使用类.静态字段的方式访问。

29、静态方法内部只能访问静态字段，没有this指向。实例对象访问静态字段和方法会有警告。java内置了许多工具类，本质上就是类中的静态方法。

30、Java内建的访问权限包括public、protected、private和package（默认）权限；
Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；final修饰符不是访问权限，它可以修饰class（不继承）、field（不可变）和method（不覆写）；一个.java文件只能包含一个public类，但可以包含多个非public类。

31、jar包相当于包class文件组织起来了，方便下载和使用，MANIFEST.MF定义主入口函数，可直接运行jar包。

32、包装类型类似于将基本类型引申为引用类型class，可以进行自动包装，包装类内部提供了大量实用方法。

33、静态工厂方法即是以静态方法返回一个以缓存的实例，例如两次Integer.valueOf(100);的返回结果其实指向的是同一个对象。包装类型的比较需要使用equal方法。

34、如果class内部定义若干private修饰的字段，并通过getter、setter操纵，则这种模式称之为javabean。

35、enum枚举类型适合进行查询比较，可以使用==，因为每个enum只被实例化一次。

36、异常通过try、catch捕获并处理，方法定义跟上throws...表示调用该方法可能会抛出异常，因此调用方必须被包裹在try语句块中。main函数是最后一次可以处理异常的地方。

37、反射：JVM为每个加载的class及interface创建了对应的class实例来保存它们相关信息，通过class获取实例信息的方法称之为反射。另外，jvm采用动态加载的方式加载class，可根据运行需要自动加载需要的类，并通过反射创建实例，运行方法。

38、反射的应用不符合封装这一特性，它更多的是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定信息（字段），甚至修改。getField，并利用get、set读取、设置字段值。

39、反射也可以获取实例的方法信息，通过getMethod获取，并利用invoke执行方法。

40、反射获取构造方法为getConstructor

41、泛型是一种模板，可以适用于多种不同的对象，比如可以定义

ArrayList\<String> strList = new ArrayList\<String>();也可以定义

ArrayList\<Person> personList = new ArrayList\<Person>();

42、泛型可以向上转型ArrayList\<Integer>->List\<Integer>，但不允许ArrayList\<Integer>->ArrayList\<Number>。

43、泛型除了可以当成数组以外，还可以用于实现接口，比如类对象想要实现比较功能，就必须要实现Comparable\<T>这个接口。

44、集合可在内部持有若干其他同类型对象，并对外提供访问接口，相比数组的固定大小和按索引访问，集合可实现可变大小。集合collection包含了三大类，List（有序列表集合）、Set（无重复元素集合）、Map（键值映射表集合）

45、集合的访问总是通过迭代器实现的，Iterator，无需知道内部采用什么方式存储的。

46、list的实现分为ArrayList和LinkedList，由于iterator访问效率最高，因此for each循环默认实现的是iterator遍历。

47、map是以键值对的形式存放数据对象的，通过在map中put('key',object)，便可通过key高效的查询到目标对象，本质是hashmap。同样迭代器使用for each循环，遍历map.ketSet()即可获取到所有key。另外，key值存放是无序的。

48、set是存放无重复元素的集合，hashset（无序）、sortedset（有序）.

49、单例模式，该模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。优点是解决了频繁创建和销毁的问题，避免对资源的多重占用，比如文件读写，只需要有一个file对象即可。

50、在hashmap中，若要判断两个key对象是否相同，首先需要重写key下的equals方法，这样即可判断引用不同，但内容是否相同了。内容相同之后，由于map中key的无重复性，因此equals下判断相同的两个对象，也需要得到同一个hashcode码才行，所以还需再重写hashcode方法。