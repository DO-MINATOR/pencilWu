1、死锁：多个线程互相持有对方所需要的资源，又不主动释放，导致程序停滞不前。

2、死锁条件：

  互斥、请求与保持、不剥夺、循环等待（2+个线程形成请求链）

3、定位死锁，jps查看java程序pid，jstack pid查看程序死锁原因。

![image-20200527161729243](https://imagebag.oss-cn-chengdu.aliyuncs.com/img/image-20200527161729243.png)

  第二种是通过编写代码，ThreadMaxBean，可以检测到发生死锁线程，进而进行程序控制干预。

4、修复死锁：

  （避免）更换加锁顺序：

哲学家就餐：最后一个哲学家始终先拿右边，再拿左边

​    银行转账：根据hash值决定先加哪把锁

​    银行家算法

  （恢复）检测与恢复：

​    当检测到发生死锁时，根据优先级/运行时间/占用情况决定停止掉某个线程，或者让某个线程释放锁。

5、实际工程避免死锁：

  使用ReentrantLock.trylock方式，注意手动释放锁

  使用并发类提供的同步对象，而不是自己加锁保护，如针对非原子操作的map对象的操作，set、get、have操作等都是非原子操作的，此时宜采用ConcurrentHashmap，因为它的锁开销小，也保证了执行原子性。

  降低加锁范围

  尽量减少锁嵌套

  使用银行家算法

6、活跃性问题，除了死锁还有活锁，活锁和锁无关，只是在代码执行过程中陷入了循环往复无意义的操做，通常这种操作是非常消耗CPU资源的。饥饿是指线程长时间得不到CPU。