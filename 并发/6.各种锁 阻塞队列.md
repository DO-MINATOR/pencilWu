1、lock相比synchronized有些不同：

  a、发生异常无法主动释放锁，而synchronized发生异常时，只要走出包裹代码块，就会释放，因此使用lock.lock一定使用try...finally...中释放锁

  b、lock.lock和synchronized在等带锁进入blocked状态时无法响应interrupt，因此建议使用lock.trylock()，可选等待时间，这样，不会陷入永久等待。

  c、lock.lockInterruptibly相当于trylock将时间设置为无限，但和trylock一样，也可以响应interrupt。

2、锁的分类

![image-20200527161915996](https://imagebag.oss-cn-chengdu.aliyuncs.com/img/image-20200527161859994.png)

**悲观锁**：访问共享资源前必须加锁，阻塞和唤醒开销大

**乐观锁**：线程修改对象时不加锁，修改过程中检查是否有别的线程修改过，如果修改过，则本线程此次修改无效，报错或者重试。典型例子：原子类、并发容器等（AtomicInteger，修改时没有强制加锁，开销小；数据库查询并修改通过version控制乐观锁）

二者对比：悲观锁加解锁时间固定，乐观锁虽然没有加解锁过程，但有可能会进行反复的重试、报错。

适用场景：如果并发写量大，或者同步代码块耗时较长，那么采用悲观锁；如果都是读取线程，或者并发量很小，则采用乐观锁。

**可重入锁/递归锁**：通过lock.getHoldCount获取当前获得该锁的数量，可重入，当前线程如果已经持有这把锁，那么可在不释放的情况下继续获得该锁。

**非公平锁**：A、B线程，A先持有锁，释放后，B由于唤醒操作会经历一定空档期，此时如果C线程恰好进来，那么C就可以直接获取到该锁，这样可以提升系统总体吞吐量。允许一次插队，lock默认为非公平锁

**公平锁**：通过Reentrylock()构造参数为true指定为公平锁，此后获取锁的顺序即为加锁队列的线程顺序，不允许插队。trylock忽略公平原则，但是一次插队，非自旋

![image-20200527161908553](https://imagebag.oss-cn-chengdu.aliyuncs.com/img/image-20200527161908553.png)

  **读写锁（共享/排他锁）**：一种特殊的锁，内部拥有两把锁，且相互关联。

  **读锁**：ReentrantReadWriteLock.ReadLock，允许同时读，无法升级

  **写锁**：ReentrantReadWriteLock.WriteLock，只能一写，可以降级

  策略一：读线程可以插队，提高读效率，但会造成写线程饥饿

  策略二：读线程只有在阻塞队列头不是写线程才可以插队。

  策略三：不允许任何线程插队

**注：前二者是非公平锁，第三个是公平锁（一般不考虑和研究）**

![image-20200527161859994](https://imagebag.oss-cn-chengdu.aliyuncs.com/img/image-20200527161915996.png)

**上图是非公平锁流程，任意新线程加入，直接进行抢锁，抢到就执行，没抢到加入阻塞队列（按照请求锁的先后顺序排队）在读写锁中（默认非公平实现），写线程可以插队，读线程只有在队头线程不是请求写锁的情况下可以插队，否则写锁很有可能饥饿。**

**自旋锁**：在获取锁之前会一直占用CPU，直到前面线程释放锁，默认的锁是非自旋锁，即如果得不到锁，就放入到阻塞队列中。产生自旋锁的原因是，CPU从阻塞队列中唤醒一个线程的开销较大，因此适用于：

服务器有多核，或者锁临界区较短小，通常Atomic原子类采用自旋锁CAS

**可中断锁**：通常的synchronized和reentrylock.lock方法在获取不到锁进入阻塞队列后，就只能等待锁，而trylock、lockInterruptibly这两个方法都可以响应interrupt，避免无休止等待。

3、JVM对锁的优化机制

  自旋锁在循环一定时间后，若还是得不到执行，便进入阻塞队列。

  锁粗化：把频繁加解锁的代码合为一个同步块

  锁去除：如果认为该方法已经私有（别的线程不可能执行）则去除该锁。