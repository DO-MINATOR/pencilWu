1、java语言提供的数组是基本的数组类型，通过封装数组并提供方法，可以实现诸如AddIndex、Get、RemoveIndex等功能，另外，通过满换策略实现数组的动态增长和缩减，将定义的数组类型添加泛型可以轻松的覆盖到其他类型数组。

```java
public class Array<T> {
   private T[] data;
   private int size;
 
   public Array(int capacity) {
     size = 0;
     data = (T[]) new Object[capacity];
   }
 }
```

2、时间复杂图分析，通常使用最坏时间分析，但有时注意应当使用均摊复杂度，防止复杂度震荡的方法是将满替策略进行延迟(lazy)调用。

3、Stack栈其实内部也是使用数组实现，因为底层实现机制仍然通过数组以实现，因此可以直接调用1中的对象及其方法。

4、Queue也是使用数组以实现的，通过对数组的不同处理，可以形成数组队列和循环队列。由于数组队列在每次取出头元素的时候会进行后位补齐操作，因此时间复杂度为O(n)；而循环队列取操作只需要维护队头索引，时间复杂度为O(1)。

5、**数组**：基本数组->动态数组->带泛型的动态数组n、n、n(特别的，增删最后一个元素，考虑到动态增减，最坏复杂度为n，均摊复杂度为1!)

数组栈：在数组尾部进行增减 1、1

数组队列：尾部添加、首部删减1、n 

循环队列：尾部添加，首部删减，循环移动索引1、1

**链表**：定义节点类，维护头部指针和size大小n、n、n

```java
private class Node {
   E e;
   Node next;
   public Node(E e, Node next) {
     this.e = e;
     this.next = next;
   }
   public Node(E e) {
     this(e, null);
   }
   public Node() {
     this(null);
   }
   @Override
   public String toString() {
     return e.toString();
   }
 }
 private Node head;
 private int size;
```

链表栈：头部指针进行增减1、1

链表队列：头部指针添加，尾部指针删减，移动索引1、1

6、递归函数，拥有某种宏观意义的特殊函数，本质上是将该函数的工作划分为比它减一的工作，同时给出最基本工作的结果，一般而言格式如下：

function A(B){

   if():

​    return ...;

  return b+A(B-1);

7、递归逻辑“简单”，代码简洁，但由于是函数调用，因此时间开销，栈占用较大。

8、**树**T具有动态数据结构性，本质通过两个链接指针穿插整棵树

```java
private class Node {
   T e;
   Node left, right;
 
   public Node(T e) {
     this.e = e;
     left = null;
     right = null;
   }
 
   @Override
   public String toString() {
     return e.toString();
   }
 }
 
 private Node root;
 private int size;
```

9、**二分搜索树**BST的节点具有可比较性，中序遍历依次递增。

10、数和数组、链表类似，有上层的实现数据结构，诸如Set和Map；set由于无法存放重复元素，因此使用二分搜索树可以实现这样的功能。

11、搜索树的前中后序遍历可以使用递归操作，也有非递归的实现，前序非递归可以采用栈的实现方式。

12、树的前序遍历可通过stack，层序遍历通过queue。

13、Set是二分搜索树的高层数据结构，二分搜索数本身就具有了set的所有功能。

14、链表和二分搜索树都是基本的动态数据结构，链表也可以实现set的功能。

前者时间复杂度为：n、n、n，后者为：logn、logn、logn

*特别的：*如果二分搜索树每次递增地添加元素，则退化为单链表.可以改进为平衡二叉树或者红黑树

15、Map是存储Key-Value键值对这样的数据结构，生活中有很多类似这样字典的业务需求，底层实现可以采用链表和二分搜索树。

16、链表节点存储Key、value和next节点，二分搜索树一样。

17、二分树实现set和map比链表实现set、map时间复杂度低，另外，java标准库提供了Linklistset(map)/Treeset(map)即是这样的实现，tree更准确的说应当是平衡二叉树/红黑树，还有强大的hashset/hashmap。

18、**堆**可以采用顺序线性数据进行存储，但这样的时间复杂度为n。如果采用“完全二叉树”，则时间复杂度优化到logn，且不会退化为“单链表”，实际上，底层采用的是动态数组，用于模拟“树”。堆在进行添加和删除元素时，分别执行的是siftup和siftdown。

19、Heapify操作是对最大堆的一个优化，之前在往堆中添加元素的时候，一个一个添加，时间复杂度为logn，如果采用数组建堆的方式，即一开始就将数组存放在整个堆中，在进行从下往上的siftdown操作，虽然该操作时间复杂度仍为logn，但是整体会少执行一半的元素个数。

19、基于堆这种数据结构，可以实现优先队列。

20、**线段树**存取的是一个范围内的数据统计，通过完全二叉树或者线性数组实现，使用线性数组查询和修改的时间复杂度是O(n)，而线段树是O(logn)。
 21、**trie**是一种多叉树，又叫**字典树**，针对字符串处理发明的一种数据结构，每个节点只保存一个字母的信息，并通过map的形式链接到下一个字母节点信息，增删改查时间复杂度相较二分搜索树为O(单词长度)。

22、**并查集**是一种数据之间合并的操作，通常的查询和合并这两个操作的时间复杂度为O(h)，为了不断优化并查集算法效能，就要减少查询和合并的高度，通常在合并过程中有基于size和rank的合并操作，而查询中有路径压缩算法，通常有非递归和递归两种实现。常用的做法是综合路径压缩算法和基于rank。

23、**AVL平衡二叉树**是一种可以自平衡的二分搜索树，之前的BST如果添加或者删除元素没有任何约束的话，则很可能退化成单链表，最坏时间复杂度为O(n)，当利用平衡因子(>1)实现左右旋转，则可以实现自平衡，最坏时间复杂度就为O(logn)。

24、二分搜索树在随机数据时性能表现优良，如果局部顺序操作，平衡二叉树可以通过自平衡抑制树高度无限增长，然而自平衡这种方式其实是不高效的，无法通过一个保守的旋转操作次数完成，而**2-3**树可以通过“融合+单走”这样的方式实现自平衡，并且它是完全平衡二叉树，即所有子树高度一致，**红黑树**模拟了2-3树且保证节点一般性，即每次新添加的节点永远是红色节点，要么融合形成2树，要么形成3树，前者进行“融合”操作，后者进行“单走”操作，所以每次平衡操作数量较少，在增删操作较多时，**红黑树**优于**平衡二叉树**。然而红黑树是黑平衡的，所以最大时间复杂度为O(2*logn)。

25、**哈希表**，是一种更加高级的分别有序集合（映射），通过将传入的对象进行哈希值映射到不同的有序集合中，使得原本只有一个树形结构的二叉树变成了多颗二叉树，由于映射这一步操作可以在O(1)复杂度中完成，因此时间复杂度由原来的O(logn)变为了O(logn/m)其中m为映射大小，即有多少个二叉树，空间换时间的方式可以进一步提高存取效率。需要注意的是相同key和某些不同key有可能发生hash冲突，即体现在这些key-value存放在一颗二叉树中，在原来的二分搜索树种，只用使用comparator进行区分与排序，而在hashmap中，key不必实现comparator，（因为内部使用默认的key值排序），但必须实现equals方法。